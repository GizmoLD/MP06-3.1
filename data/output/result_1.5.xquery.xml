<preguntes>
  <pregunta>
    <titol Title="Why does the SARS-Cov2 coronavirus genome end in aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa (33 a's)?"/>
    <body Body="&lt;p&gt;The SARS-Cov2 coronavirus's genome was released, and is now available on Genbank.  Looking at it...&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;pre&gt;&lt;code&gt;    1 attaaaggtt tataccttcc caggtaacaa accaaccaac tttcgatctc ttgtagatct&#xA;   61 gttctctaaa cgaactttaa aatctgtgtg gctgtcactc ggctgcatgc ttagtgcact&#xA;  121 cacgcagtat aattaataac taattactgt cgttgacagg acacgagtaa ctcgtctatc&#xA;  ...&#xA;29761 acagtgaaca atgctaggga gagctgccta tatggaagag ccctaatgtg taaaattaat&#xA;29821 tttagtagtg ctatccccat gtgattttaa tagcttctta ggagaatgac aaaaaaaaaa&#xA;29881 aaaaaaaaaa aaaaaaaaaa aaa&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;  &#xA;  &lt;p&gt;&lt;sub&gt;&lt;a href=&quot;https://www.ncbi.nlm.nih.gov/nuccore/MN908947&quot; rel=&quot;noreferrer&quot;&gt;Wuhan seafood market pneumonia virus isolate Wuhan-Hu-1, complete genome&lt;/a&gt;, Genbank&lt;/sub&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Geeze, that's a lot of &lt;a href=&quot;https://en.wikipedia.org/wiki/Adenine&quot; rel=&quot;noreferrer&quot;&gt;a&lt;/a&gt; nucleotides---I don't think that's just random.  I would guess that it's either an artifact of the sequencing process, or there is some underlying biological reason.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;Question&lt;/strong&gt;: Why does the SARS-Cov2 coronavirus genome end in 33 a's?&lt;/p&gt;&#xA;"/>
    <tags Tags="&lt;phylogenetics&gt;&lt;sequence-alignment&gt;&lt;fasta&gt;&lt;phylogeny&gt;&lt;covid-19&gt;"/>
    <score Score="191"/>
    <resposta>
      <id_res Id="11229"/>
      <body_resp Body="&lt;p&gt;Good observation! The 3' poly(A) tail is actually a very common feature of positive-strand RNA viruses, including coronaviruses and picornaviruses.&lt;/p&gt;&#xA;&lt;p&gt;For coronaviruses in particular, we know that the poly(A) tail is required for replication, functioning in conjunction with the 3' untranslated region (UTR) as a cis-acting signal for negative strand synthesis and attachment to the ribosome during translation. Mutants lacking the poly(A) tail are severely compromised in replication. Jeannie Spagnolo and Brenda Hogue report:&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;The 3? poly (A) tail plays an important, but as yet undefined role in Coronavirus genome replication. To further examine the requirement for the Coronavirus poly(A) tail, we created truncated poly(A) mutant defective interfering (DI) RNAs and observed the effects on replication. Bovine Coronavirus (BCV) and mouse hepatitis Coronavirus A59 (MHV-A59) DI RNAs with tails of 5 or 10 A residues were replicated, albeit at delayed kinetics as compared to DI RNAs with wild type tail lengths (&amp;gt;50 A residues). A BCV DI RNA lacking a poly(A) tail was unable to replicate; however, a MHV DI lacking a tail did replicate following multiple virus passages. Poly(A) tail extension/repair was concurrent with robust replication of the tail mutants. Binding of the host factor poly(A)- binding protein (PABP) appeared to correlate with the ability of DI RNAs to be replicated. Poly(A) tail mutants that were compromised for replication, or that were unable to replicate at all exhibited less in vitro PABP interaction. The data support the importance of the poly(A) tail in Coronavirus replication and further delineate the minimal requirements for viral genome propagation.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&quot;https://link.springer.com/chapter/10.1007/978-1-4615-1325-4_68&quot; rel=&quot;noreferrer&quot;&gt;Spagnolo J.F., Hogue B.G. (2001) Requirement of the Poly(A) Tail in Coronavirus Genome Replication. In: Lavi E., Weiss S.R., Hingley S.T. (eds) The Nidoviruses. Advances in Experimental Medicine and Biology, vol 494. Springer, Boston, MA&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;Yu-Hui Peng &lt;em&gt;et al.&lt;/em&gt; also report that the length of the poly(A) tail is regulated during infection:&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Similar to eukaryotic mRNA, the positive-strand coronavirus genome of ~30 kilobases is 5’-capped and 3’-polyadenylated. It has been demonstrated that the length of the coronaviral poly(A) tail is not static but regulated during infection; however, little is known regarding the factors involved in coronaviral polyadenylation and its regulation. Here, we show that during infection, the level of coronavirus poly(A) tail lengthening depends on the initial length upon infection and that the minimum length to initiate lengthening may lie between 5 and 9 nucleotides. By mutagenesis analysis, it was found that (i) the hexamer AGUAAA and poly(A) tail are two important elements responsible for synthesis of the coronavirus poly(A) tail and may function in concert to accomplish polyadenylation and (ii) the function of the hexamer AGUAAA in coronaviral polyadenylation is position dependent. Based on these findings, we propose a process for how the coronaviral poly(A) tail is synthesized and undergoes variation. Our results provide the first genetic evidence to gain insight into coronaviral polyadenylation.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&quot;https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0165077&quot; rel=&quot;noreferrer&quot;&gt;Peng Y-H, Lin C-H, Lin C-N, Lo C-Y, Tsai T-L, Wu H-Y (2016) Characterization of the Role of Hexamer AGUAAA and Poly(A) Tail in Coronavirus Polyadenylation. PLoS ONE 11(10): e0165077&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;This builds upon prior work by Hung-Yi Wu &lt;em&gt;et al&lt;/em&gt;, which showed that the coronaviral 3' poly(A) tail is approximately 65 nucleotides in length in both genomic and sgmRNAs at peak viral RNA synthesis, and also observed that the precise length varied throughout infection. Most interestingly, they report:&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Functional analyses of poly(A) tail length on specific viral RNA species, furthermore, revealed that translation, in vivo, of RNAs with the longer poly(A) tail was enhanced over those with the shorter poly(A). Although the mechanisms by which the tail lengths vary is unknown, experimental results together suggest that the length of the poly(A) and poly(U) tails is regulated. One potential function of regulated poly(A) tail length might be that for the coronavirus genome a longer poly(A) favors translation. The regulation of coronavirus translation by poly(A) tail length resembles that during embryonal development suggesting there may be mechanistic parallels.&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&quot;https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3726627/&quot; rel=&quot;noreferrer&quot;&gt;Wu HY, Ke TY, Liao WY, Chang NY. Regulation of coronaviral poly(A) tail length during infection. PLoS One. 2013;8(7):e70548. Published 2013 Jul 29. doi:10.1371/journal.pone.0070548&lt;/a&gt;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;It's also worth pointing out that poly(A) tails at the 3' end of RNA are not an unusual feature of viruses. Eukaryotic mRNA almost always contains poly(A) tails, which are added post-transcriptionally in a process known as polyadenylation. It should not therefore be surprising that positive-strand RNA viruses would have poly(A) tails as well. In eukaryotic mRNA, the central sequence motif for identifying a polyadenylation region is AAUAAA, identified way back in the 1970s, with more recent research confirming its ubiquity. &lt;a href=&quot;https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3175714/&quot; rel=&quot;noreferrer&quot;&gt;Proudfoot 2011&lt;/a&gt; is a nice review article on poly(A) signals in eukaryotic mRNA.&lt;/p&gt;&#xA;"/>
      <score_resp Score="163"/>
    </resposta>
  </pregunta>
  <pregunta>
    <titol Title="What's the most efficient file format for the storage of DNA sequences?"/>
    <body Body="&lt;p&gt;I'd like to learn which format is most commonly used for storing the full human genome sequence (4 letters without a quality score) and why.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I assume that storing it in plain-text format would be very inefficient. I expect a binary format would be more appropriate (e.g. 2 bits per nucleotide).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Which format is most common in terms of space efficiency?&lt;/p&gt;&#xA;"/>
    <tags Tags="&lt;human-genome&gt;&lt;storage&gt;&lt;file-formats&gt;"/>
    <score Score="52"/>
    <resposta>
      <id_res Id="3"/>
      <body_resp Body="&lt;p&gt;Genomes are commonly stored as either fasta files (.fa) or twoBit (.2bit) files. Fasta files store the entire sequence as text and are thus not particularly compressed. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;twoBit files store each nucleotide in two bits and contain additional metadata that indicates where there's regions containing &lt;code&gt;N&lt;/code&gt; (unknown) bases.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For more information, see the documentation on the twoBit format at the &lt;a href=&quot;http://genome.ucsc.edu/FAQ/FAQformat.html#format7&quot; rel=&quot;noreferrer&quot;&gt;UCSC genome browser&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You can convert between twoBit and fasta format using the &lt;a href=&quot;https://genome.ucsc.edu/goldenpath/help/twoBit.html&quot; rel=&quot;noreferrer&quot;&gt;faToTwoBit and twoBitToFa utilities&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For the human genome, you can download it in either fasta or twoBit format here: &lt;a href=&quot;http://hgdownload.cse.ucsc.edu/goldenPath/hg38/bigZips/&quot; rel=&quot;noreferrer&quot;&gt;http://hgdownload.cse.ucsc.edu/goldenPath/hg38/bigZips/&lt;/a&gt;&lt;/p&gt;&#xA;"/>
      <score_resp Score="42"/>
    </resposta>
  </pregunta>
  <pregunta>
    <titol Title="Feature annotation: RefSeq vs Ensembl vs Gencode, what's the difference?"/>
    <body Body="&lt;p&gt;What are the actual differences between different annotation databases? &lt;/p&gt;&#xA;&#xA;&lt;p&gt;My lab, for reasons still unknown to me, prefers Ensembl annotations (we're working with transcript/exon expression estimation), while some software ship with RefSeq annotations. Are there significant differences between them today, or are they, for all intents and purposes, interchangeable (e.g., are exon coordinates between RefSeq and Ensembl annotations interchangeable)?&lt;/p&gt;&#xA;"/>
    <tags Tags="&lt;sequence-annotation&gt;&lt;ensembl&gt;&lt;refseq&gt;&lt;gencode&gt;"/>
    <score Score="46"/>
    <resposta>
      <id_res Id="64"/>
      <body_resp Body="&lt;p&gt;To add to &lt;a href=&quot;https://bioinformatics.stackexchange.com/a/38/203&quot;&gt;rightskewed answer&lt;/a&gt;:&#xA;While it is true that:&lt;/p&gt;&#xA;&lt;p&gt;Gencode is an additive set of annotation (the manual one done by Havana and an automated one done by Ensembl),&lt;/p&gt;&#xA;&lt;p&gt;the annotation (GTF) files are quite similar for a few exceptions involving the X chromosome and Y par and additional remarks in the Gencode file (see more at &lt;a href=&quot;https://www.gencodegenes.org/faq.html&quot; rel=&quot;noreferrer&quot;&gt;FAQ - Gencode&lt;/a&gt;).&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;What are the actual differences between different annotation databases?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;They are a few differences, but the main one  &lt;strong&gt;for me (and it could be stupid)&lt;/strong&gt; is&lt;/p&gt;&#xA;&lt;p&gt;that &lt;strong&gt;Refseq is developed by the American NCBI&lt;/strong&gt; and&lt;/p&gt;&#xA;&lt;p&gt;the &lt;strong&gt;ENSEMBL is mainly developed by the European EMBL-EBI.&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;Often, labs or people will just start using what is the best known to them (because of a course or workshop) or because they start working with one of the databases with one specific tool and keep with it later.&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;My lab, for reasons still unknown to me, prefers Ensembl annotations (we're working with transcript/exon expression estimation), while some software ship with RefSeq annotations.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;Your lab might be mostly European based people or they might also have read papers like the one from Frankish et al.  Comparison of GENCODE and RefSeq gene annotation and the impact of reference geneset on variant effect prediction. BMC Genomics 2015; 16(Suppl 8):S2 - DOI: 10.1186/1471-2164-16-S8-S2&lt;/p&gt;&#xA;&lt;p&gt;From the &lt;a href=&quot;https://bmcgenomics.biomedcentral.com/articles/10.1186/1471-2164-16-S8-S2&quot; rel=&quot;noreferrer&quot;&gt;Frankish et al. paper&lt;/a&gt; paper:&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;The GENCODE Comprehensive transcripts contain more exons, have greater genomic coverage and capture many more variants than RefSeq in both genome and exome datasets, while the GENCODE Basic set shows a higher degree of concordance with RefSeq and has fewer unique features.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;As for:&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Are there significant differences between them today, or are they, for all intents and purposes, interchangeable (e.g., are exon coordinates between RefSeq and Ensembl annotations interchangeable)?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;No. I don't think they are great differences between them as that the global picture should stay the same (although you will see different results if you are interested in a small set of genes). However, &lt;strong&gt;they are not directly interchangeable&lt;/strong&gt;. Particularly as there are many versions of Ensembl and Refseq based on different genome annotations (and those won't be interchangeable between themselves either in most cases).&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;However, you can easily translate&lt;/strong&gt; most[1] of your Refseq IDs to ENSEMBL IDs and vice-versa with tools as &lt;a href=&quot;http://www.ensembl.org/biomart/martview&quot; rel=&quot;noreferrer&quot;&gt;http://www.ensembl.org/biomart/martview&lt;/a&gt; for example (there are devoted libraries/API as well like &lt;a href=&quot;https://bioconductor.org/packages/release/bioc/html/biomaRt.html&quot; rel=&quot;noreferrer&quot;&gt;Biocondutor: biomaRt&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;[1] Most as sometimes, they might be annotated in one of the database but haven't (yet) an equivalent in the other.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;EDIT&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;In fine, even if people tends to keep to what they are used to (and that the annotations are constantly expanded and corrected) depending on the research subject one might be interested in using one database over another:&lt;/p&gt;&#xA;&lt;p&gt;From &lt;a href=&quot;https://bmcgenomics.biomedcentral.com/articles/10.1186/s12864-015-1308-8&quot; rel=&quot;noreferrer&quot;&gt;Zhao S, Zhang B. A comprehensive evaluation of ensembl, RefSeq, and UCSC annotations in the context of RNA-seq read mapping and gene quantification. BMC Genomics. 2015;16: 97.&lt;/a&gt; paper:&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;When choosing an annotation database, researchers should keep in mind that no database is perfect and some gene annotations might be inaccurate or entirely wrong. [..] Wu et al. [27] suggested that when conducting research that emphasizes reproducible and robust gene expression estimates, a less complex genome annotation, such as RefGene, might be preferred. When conducting more exploratory research, a more complex genome annotation, such as Ensembl, should be chosen.&lt;/p&gt;&#xA;&lt;p&gt;[..]&lt;/p&gt;&#xA;&lt;p&gt;[27] Wu P-Y, Phan JH, Wang MD. Assessing the impact of human genome annotation choice on RNA-seq expression estimates. BMC Bioinformatics. 2013;14(Suppl 11):S8. doi: 10.1186/1471-2105-14-S11-S8.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;"/>
      <score_resp Score="24"/>
    </resposta>
  </pregunta>
  <pregunta>
    <titol Title="What is the difference between FASTA, FASTQ, and SAM file formats?"/>
    <body Body="&lt;p&gt;I'd like to learn the differences between 3 common formats such as &lt;a href=&quot;https://en.wikipedia.org/wiki/FASTA_format&quot; rel=&quot;noreferrer&quot;&gt;FASTA&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/FASTQ_format&quot; rel=&quot;noreferrer&quot;&gt;FASTQ&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/SAM_(file_format)&quot; rel=&quot;noreferrer&quot;&gt;SAM&lt;/a&gt;. How they are different? Are there any benefits of using one over another?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Based on Wikipedia pages, I can't tell the differences between them.&lt;/p&gt;&#xA;"/>
    <tags Tags="&lt;fasta&gt;&lt;fastq&gt;&lt;file-formats&gt;&lt;sam&gt;"/>
    <score Score="42"/>
    <resposta>
      <id_res Id="385"/>
      <body_resp Body="&lt;p&gt;Let’s start with what they have in common: All three formats store&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;sequence data, and&lt;/li&gt;&#xA;&lt;li&gt;sequence metadata.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;Furthermore, all three formats are text-based.&lt;/p&gt;&#xA;&lt;p&gt;However, beyond that all three formats are different and serve different purposes.&lt;/p&gt;&#xA;&lt;p&gt;Let’s start with the simplest format:&lt;/p&gt;&#xA;&lt;h3&gt;FASTA&lt;/h3&gt;&#xA;&lt;p&gt;FASTA stores a variable number of sequence records, and for each record it stores the sequence itself, and a sequence ID. Each record starts with a header line whose first character is &lt;code&gt;&amp;gt;&lt;/code&gt;, followed by the sequence ID. The next lines of a record contain the actual sequence.&lt;/p&gt;&#xA;&lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/FASTA_format&quot; rel=&quot;noreferrer&quot;&gt;Wikipedia artice&lt;/a&gt; gives several examples for peptide sequences, but since FASTQ and SAM are used exclusively (?) for nucleotide sequences, here’s a nucleotide example:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;&amp;gt;Mus_musculus_tRNA-Ala-AGC-1-1 (chr13.trna34-AlaAGC)&#xA;GGGGGTGTAGCTCAGTGGTAGAGCGCGTGCTTAGCATGCACGAGGcCCTGGGTTCGATCC&#xA;CCAGCACCTCCA&#xA;&amp;gt;Mus_musculus_tRNA-Ala-AGC-10-1 (chr13.trna457-AlaAGC)&#xA;GGGGGATTAGCTCAAATGGTAGAGCGCTCGCTTAGCATGCAAGAGGtAGTGGGATCGATG&#xA;CCCACATCCTCCA&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;The ID can be in any arbitrary format, although &lt;a href=&quot;https://en.wikipedia.org/wiki/FASTA_format#Sequence_identifiers&quot; rel=&quot;noreferrer&quot;&gt;several conventions exist&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;In the context of nucleotide sequences, FASTA is mostly used to store reference data; that is, data extracted from a curated database; the above is adapted from &lt;a href=&quot;http://gtrnadb.ucsc.edu/&quot; rel=&quot;noreferrer&quot;&gt;GtRNAdb&lt;/a&gt; (a database of tRNA sequences).&lt;/p&gt;&#xA;&lt;h3&gt;FASTQ&lt;/h3&gt;&#xA;&lt;p&gt;FASTQ was conceived to solve a specific problem arising during sequencing: Due to how different sequencing technologies work, the confidence in each &lt;a href=&quot;https://biology.stackexchange.com/a/1873/166&quot;&gt;base call&lt;/a&gt; (that is, the estimated probability of having correctly identified a given nucleotide) varies. This is expressed in the &lt;a href=&quot;https://en.wikipedia.org/wiki/Phred_quality_score&quot; rel=&quot;noreferrer&quot;&gt;Phred quality score&lt;/a&gt;. FASTA had no standardised way of encoding this. By contrast, a FASTQ record &lt;a href=&quot;https://en.wikipedia.org/wiki/FASTQ_format#Encoding&quot; rel=&quot;noreferrer&quot;&gt;contains a sequence of quality scores&lt;/a&gt; for each nucleotide.&lt;/p&gt;&#xA;&lt;p&gt;A FASTQ record has the following format:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;A line starting with &lt;code&gt;@&lt;/code&gt;, containing the sequence ID.&lt;/li&gt;&#xA;&lt;li&gt;One or more lines that contain the sequence.&lt;/li&gt;&#xA;&lt;li&gt;A new line starting with the character &lt;code&gt;+&lt;/code&gt;, and being either empty or repeating the sequence ID.&lt;/li&gt;&#xA;&lt;li&gt;One or more lines that contain the quality scores.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;Here’s an example of a FASTQ file with two records:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;@071112_SLXA-EAS1_s_7:5:1:817:345&#xA;GGGTGATGGCCGCTGCCGATGGCGTC&#xA;AAATCCCACC&#xA;+&#xA;IIIIIIIIIIIIIIIIIIIIIIIIII&#xA;IIII9IG9IC&#xA;@071112_SLXA-EAS1_s_7:5:1:801:338&#xA;GTTCAGGGATACGACGTTTGTATTTTAAGAATCTGA&#xA;+&#xA;IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII6IBI&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;FASTQ files are mostly used to store short-read data from high-throughput sequencing experiments. The sequence and quality scores are usually put into a single line each, and indeed many tools assume that each record in a FASTQ file is exactly four lines long, even though this isn’t guaranteed.&lt;/p&gt;&#xA;&lt;p&gt;As with FASTA, the format of the sequence ID isn’t standardised, but different producers of FASTQ use &lt;a href=&quot;https://en.wikipedia.org/wiki/FASTQ_format#Illumina_sequence_identifiers&quot; rel=&quot;noreferrer&quot;&gt;fixed notations that follow strict conventions&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;h3&gt;SAM&lt;/h3&gt;&#xA;&lt;p&gt;SAM files are so complex that a &lt;a href=&quot;https://samtools.github.io/hts-specs/SAMv1.pdf&quot; rel=&quot;noreferrer&quot;&gt;complete description&lt;/a&gt; &lt;sup&gt;[PDF]&lt;/sup&gt; takes 15 pages. So here’s the short version.&lt;/p&gt;&#xA;&lt;p&gt;The original purpose of SAM files is to store mapping information for sequences from high-throughput sequencing. As a consequence, a SAM record needs to store more than just the sequence and its quality, it also needs to store information about where and how a sequence maps into the reference.&lt;/p&gt;&#xA;&lt;p&gt;Unlike the previous formats, SAM is tab-based, and each record, consisting of either 11 or 12 fields, fills exactly one line. Here’s an example (tabs replaced by fixed-width spacing):&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;r001  99  chr1  7 30  17M         =  37  39  TTAGATAAAGGATACTG   IIIIIIIIIIIIIIIII&#xA;r002  0   chrX  9 30  3S6M1P1I4M  *  0   0   AAAAGATAAGGATA      IIIIIIIIII6IBI    NM:i:1&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;For a description of the individual fields, refer to the documentation. The relevant bit is this: SAM can express exactly the same information as FASTQ, plus, as mentioned, the mapping information. However, SAM is also used to store read data &lt;em&gt;without&lt;/em&gt; mapping information.&lt;/p&gt;&#xA;&lt;p&gt;In addition to sequence records, SAM files can also contain a &lt;em&gt;header&lt;/em&gt;, which stores information about the reference that the sequences were mapped to, and the tool used to create the SAM file. Header information precede the sequence records, and consist of lines starting with &lt;code&gt;@&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;SAM itself is almost never used as a storage format; instead, files are stored in BAM format, which is a compact, gzipped, binary representation of SAM. It stores the same information, just more efficiently. And, in conjunction with a &lt;a href=&quot;https://en.wikipedia.org/wiki/Database_index&quot; rel=&quot;noreferrer&quot;&gt;search index&lt;/a&gt;, allows fast retrieval of individual records from the middle of the file (= fast &lt;a href=&quot;https://en.wikipedia.org/wiki/Random_access&quot; rel=&quot;noreferrer&quot;&gt;random access&lt;/a&gt;). BAM files are also much more compact than compressed FASTQ or FASTA files.&lt;/p&gt;&#xA;&lt;hr /&gt;&#xA;&lt;p&gt;The above implies a &lt;em&gt;hierarchy&lt;/em&gt; in what the formats can store: FASTA ? FASTQ ? SAM.&lt;/p&gt;&#xA;&lt;p&gt;In a typical high-throughput analysis workflow, you will encounter all three file types:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;FASTA to store the reference genome/transcriptome that the sequence fragments will be mapped to.&lt;/li&gt;&#xA;&lt;li&gt;FASTQ to store the sequence fragments before mapping.&lt;/li&gt;&#xA;&lt;li&gt;SAM/BAM to store the sequence fragments after mapping.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;"/>
      <score_resp Score="62"/>
    </resposta>
  </pregunta>
  <pregunta>
    <titol Title="Why do some assemblers require an odd-length kmer for the construction of de Bruijn graphs?"/>
    <body Body="&lt;p&gt;Why do some assemblers like &lt;a href=&quot;https://github.com/aquaskyline/SOAPdenovo2&quot; rel=&quot;noreferrer&quot;&gt;SOAPdenovo2&lt;/a&gt; or &lt;a href=&quot;https://github.com/dzerbino/velvet&quot; rel=&quot;noreferrer&quot;&gt;Velvet&lt;/a&gt; require an odd-length &lt;em&gt;k&lt;/em&gt;-mer size for the construction of de Bruijn graph, while some other assemblers like &lt;a href=&quot;https://github.com/bcgsc/abyss&quot; rel=&quot;noreferrer&quot;&gt;ABySS&lt;/a&gt; are fine with even-length &lt;em&gt;k&lt;/em&gt;-mers?&lt;/p&gt;&#xA;"/>
    <tags Tags="&lt;ngs&gt;&lt;assembly&gt;&lt;k-mer&gt;&lt;de-bruijn-graphs&gt;"/>
    <score Score="35"/>
    <resposta>
      <id_res Id="158"/>
      <body_resp Body="&lt;p&gt;From the &lt;a href=&quot;http://www.ebi.ac.uk/~zerbino/velvet/Manual.pdf&quot; rel=&quot;noreferrer&quot;&gt;manual of Velvet&lt;/a&gt;:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;it must be an odd number, to avoid palindromes. If you put in an even&#xA;  number, Velvet will just decrement it and proceed.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;the &lt;a href=&quot;https://en.wikipedia.org/wiki/Palindromic_sequence&quot; rel=&quot;noreferrer&quot;&gt;palindromes&lt;/a&gt; in biology are defined as reverse complementary sequences. The problem of palindromes is explained in this &lt;a href=&quot;https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2874646/&quot; rel=&quot;noreferrer&quot;&gt;review&lt;/a&gt;:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;Palindromes induce paths that fold back on themselves. At least one&#xA;  assembler avoids these elegantly; Velvet requires K, the length of a&#xA;  K-mer, to be odd. An odd-size K-mer cannot match its reverse&#xA;  complement.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;It is possible to construct graph with palindromes, but then the interpretation will be harder. Allowing only graphs of odd &lt;em&gt;k&lt;/em&gt;-mers is just an elegant way to avoid writing a code for interpretation of a more complicated graph.&lt;/p&gt;&#xA;"/>
      <score_resp Score="31"/>
    </resposta>
  </pregunta>
  <pregunta>
    <titol Title="Why does the FASTA sequence for coronavirus look like DNA, not RNA?"/>
    <body Body="&lt;p&gt;I'm looking at &lt;a href=&quot;https://www.ncbi.nlm.nih.gov/nuccore/MN988713.1?report=fasta&quot; rel=&quot;noreferrer&quot;&gt;a genome sequence for 2019-nCoV on NCBI&lt;/a&gt;. The FASTA sequence looks like this:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;gt;MN988713.1 Wuhan seafood market pneumonia virus isolate 2019-nCoV/USA-IL1/2020, complete genome&#xA;ATTAAAGGTTTATACCTTCCCAGGTAACAAACCAACCAACTTTCGATCTCTTGTAGATCTGTTCTCTAAA&#xA;CGAACTTTAAAATCTGTGTGGCTGTCACTCGGCTGCATGCTTAGTGCACTCACGCAGTATAATTAATAAC&#xA;TAATTACTGTCGTTGACAGGACACGAGTAACTCGTCTATCTTCTGCAGGCTGCTTACGGTTTCGTCCGTG&#xA;...  &#xA;...&#xA;TTAATCAGTGTGTAACATTAGGGAGGACTTGAAAGAGCCACCACATTTTCACCGAGGCCACGCGGAGTAC&#xA;GATCGAGTGTACAGTGAACAATGCTAGGGAGAGCTGCCTATATGGAAGAGCCCTAATGTGTAAAATTAAT&#xA;TTTAGTAGTGCTATCCCCATGTGATTTTAATAGCTTCTTAGGAGAATGACAAAAAAAAAAAA&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Coronavirus is an RNA virus, so I was expecting the sequence to consist of &lt;code&gt;AUGC&lt;/code&gt; characters. But the letters here are &lt;code&gt;ATGC&lt;/code&gt;, which looks like DNA!&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I found a possible answer, that this is the sequence of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Complementary_DNA&quot; rel=&quot;noreferrer&quot;&gt;&quot;complementary DNA&quot;&lt;/a&gt;. I read that&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;The term &lt;em&gt;cDNA&lt;/em&gt; is also used, typically in a bioinformatics context, to refer to an mRNA transcript's sequence, expressed as DNA bases (GCAT) rather than RNA bases (GCAU).&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;However, I don't believe this theory that I'm looking at a cDNA. If this were true, the end of the true mRNA sequence would be &lt;code&gt;...UCUUACUGUUUUUUUUUUUU&lt;/code&gt;, or a &quot;poly(U)&quot; tail. But I believe the coronavirus has a &lt;a href=&quot;https://en.wikipedia.org/wiki/Polyadenylation&quot; rel=&quot;noreferrer&quot;&gt;poly(A) tail&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I also found that the start of all highlighted genes begin with the sequence &lt;code&gt;ATG&lt;/code&gt;. This is the DNA equivalent of &lt;a href=&quot;https://en.wikipedia.org/wiki/Start_codon&quot; rel=&quot;noreferrer&quot;&gt;the RNA start codon &lt;code&gt;AUG&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;So, I believe what I'm looking at is the true mRNA, in 5'?3' direction, but with all &lt;code&gt;U&lt;/code&gt; converted to &lt;code&gt;T&lt;/code&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;So, is this really what I'm looking at? Is this some formatting/representation issue? Or does 2019-nCoV really contain DNA, rather than RNA?&lt;/strong&gt;&lt;/p&gt;&#xA;"/>
    <tags Tags="&lt;fasta&gt;&lt;phylogenetics&gt;&lt;ngs&gt;&lt;phylogeny&gt;&lt;covid-19&gt;"/>
    <score Score="34"/>
    <resposta>
      <id_res Id="11358"/>
      <body_resp Body="&lt;p&gt;That is the correct sequence for 2019-nCov. Coronavirus is of course an RNA virus and in fact, to my knowledge, every RNA virus in Genbank is present as cDNA (AGCT, i.e. thydmine) and not RNA (AGCU, i.e. uracil).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The reason is simple, we never sequence directly from RNA because RNA is too unstable and easily degraded by RNase. Instead the genome is reverse transcribed, either by targeted reverse transcription or random amplification and thus converted to cDNA. cDNA is stable and is essentially reverse transcribed RNA.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The cDNA is either sequenced directly or further amplified by PCR and then sequenced. Hence the sequence we observe is the cDNA rather than RNA, thus we observe thymine rather than uracil and that is how it is reported. &lt;/p&gt;&#xA;"/>
      <score_resp Score="49"/>
    </resposta>
  </pregunta>
  <pregunta>
    <titol Title="Uppercase vs lowercase letters in reference genome"/>
    <body Body="&lt;p&gt;I am using a reference genome for mm10 mouse downloaded from &lt;a href=&quot;https://www.ncbi.nlm.nih.gov/genome?term=mus%20musculus&quot; rel=&quot;noreferrer&quot;&gt;NCBI&lt;/a&gt;, and would like to understand in greater detail the difference between lowercase and uppercase letters, which make up roughly equal parts of the genome. I understand that N is used for 'hard masking' (areas in the genome that could not be assembled) and lowercase letters for 'soft masking' in repeat regions.&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;What does this soft masking actually mean? &lt;/li&gt;&#xA;&lt;li&gt;How confident can I be about the sequence in these regions?&lt;/li&gt;&#xA;&lt;li&gt;What does a lowercase n represent? &lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;"/>
    <tags Tags="&lt;fasta&gt;&lt;genome&gt;"/>
    <score Score="32"/>
    <resposta>
      <id_res Id="227"/>
      <body_resp Body="&lt;blockquote&gt;&#xA;  &lt;p&gt;What does this soft masking actually mean?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;A lot of the sequence in genomes are repetitive. Human genome, for example, has (at least) two-third repetitive elements.[1]. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;These repetitive elements are soft-masked by converting the upper case letters to lower case. An important use-case of these soft-masked bases will be in homology searches: An &lt;code&gt;atatatatatat&lt;/code&gt; will tend to appear both in human and mouse genomes but is likely non-homologous.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;How confident can I be about the sequence in these regions?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;As you can be about in non soft-masked based positions. Soft-masking is done after determining portions in the genome that are likely repetitive. There is no uncertainty whether a particular base is 'A' or 'G', just that it is part of a repeat and hence should be represented as an 'a'.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;  &lt;p&gt;What does a lowercase n represent?&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;UCSC uses &lt;a href=&quot;https://tandem.bu.edu/trf/trfdesc.html&quot; rel=&quot;noreferrer&quot;&gt;Tandom Repeat Finder&lt;/a&gt; and &lt;a href=&quot;http://www.repeatmasker.org/&quot; rel=&quot;noreferrer&quot;&gt;RepeatMasker&lt;/a&gt; for soft-masking potential repeats. NCBI most likely uses &lt;a href=&quot;https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3045581/&quot; rel=&quot;noreferrer&quot;&gt;TANTAN&lt;/a&gt;. 'N's represents no sequence information is available for that base. It being replaced by 'n' is likely an artifact of the repeat-masking software where it soft-masks an 'N' by an 'n' to indicate that portion of the genome is likely a repeat too.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;[1] &lt;a href=&quot;http://journals.plos.org/plosgenetics/article?id=10.1371/journal.pgen.1002384&quot; rel=&quot;noreferrer&quot;&gt;http://journals.plos.org/plosgenetics/article?id=10.1371/journal.pgen.1002384&lt;/a&gt;&lt;/p&gt;&#xA;"/>
      <score_resp Score="29"/>
    </resposta>
  </pregunta>
  <pregunta>
    <titol Title="Read length distribution from FASTA file"/>
    <body Body="&lt;p&gt;I have a single ~10GB FASTA file generated from an Oxford Nanopore Technologies' MinION run, with &amp;gt;1M reads of mean length ~8Kb. How can I quickly and efficiently calculate the distribution of read lengths?&lt;/p&gt;&#xA;&lt;p&gt;A naive approach would be to read the FASTA file in Biopython, check the length of each sequence, store the lengths in a numpy array and plot the results using matplotlib, but this seems like reinventing the wheel.&lt;/p&gt;&#xA;&lt;p&gt;Many solutions that work for short reads are inadequate for long reads. If I'm hey output a single (text) line per 1/10 bases, which would lead to a text output of upwards of 10,000 lines (and potentially more than 10x that) for a long read fasta.&lt;/p&gt;&#xA;"/>
    <tags Tags="&lt;fasta&gt;&lt;nanopore&gt;"/>
    <score Score="28"/>
    <resposta>
      <id_res Id="68"/>
      <body_resp Body="&lt;p&gt;If you want something quick and dirty you could rapidly index the FASTA with &lt;code&gt;samtools faidx&lt;/code&gt; and then put the lengths column through R (other languages are available) on the command line.&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;samtools faidx $fasta&#xA;cut -f2 $fasta.fai | Rscript -e 'data &amp;lt;- as.numeric (readLines (&quot;stdin&quot;)); summary(data); hist(data)'&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;This outputs a statistical summary, and creates a PDF in the current directory called Rplots.pdf, containing a histogram.&lt;/p&gt;&#xA;"/>
      <score_resp Score="20"/>
    </resposta>
  </pregunta>
  <pregunta>
    <titol Title="How to version the code and the data during the analysis?"/>
    <body Body="&lt;p&gt;I am currently looking for a system which will allow me to version both the code and the data in my research.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;I think my way of analyzing data is not uncommon, and this will be useful for many people doing bioinformatics and aiming for the reproducibility.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Here are the requrements:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Analysis is performed on multiple machines (local, cluster, server).&lt;/li&gt;&#xA;&lt;li&gt;All the code is transparently synchronized between the machines.&lt;/li&gt;&#xA;&lt;li&gt;Source code versioning.&lt;/li&gt;&#xA;&lt;li&gt;Generated data versioning.&lt;/li&gt;&#xA;&lt;li&gt;Support for large number of small generated files (&gt;10k). These also could be deleted.&lt;/li&gt;&#xA;&lt;li&gt;Support for large files (&gt;1Gb). At some point old generated files can  permanently deleted. It would be insane to have &lt;em&gt;transparent&lt;/em&gt; synchronization of those, but being able to synchronize them on demand would be nice.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;So far I am using &lt;strong&gt;git&lt;/strong&gt; + rsync/scp. But there are several downsides to it.&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Synchronization between multiple machines is a bit tedious, i.e. you have to git pull before you start working and git push after each update. I can live with that.&lt;/li&gt;&#xA;&lt;li&gt;You are not supposed to store large generated data files or large number of files inside your repository.&lt;/li&gt;&#xA;&lt;li&gt;Therefore I have to synchronize data files manually using rsync, which is error prone.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;There is something called &lt;a href=&quot;https://git-annex.branchable.com/&quot; rel=&quot;noreferrer&quot;&gt;git annex&lt;/a&gt;. It seems really close to what I need. But:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;A bit more work than git, but that's ok.&lt;/li&gt;&#xA;&lt;li&gt;Unfortunately it seems it does not work well with the large number of files. Often I have more that 10k small files in my analysis. There are some tricks to &lt;a href=&quot;http://git-annex.branchable.com/tips/Repositories_with_large_number_of_files/&quot; rel=&quot;noreferrer&quot;&gt;improve indexing&lt;/a&gt;, but it doesn't solve the issue. What I need is one symlink representing the full contents of directory.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;One potential solution is to use Dropbox or something similar (like &lt;a href=&quot;https://syncthing.net/&quot; rel=&quot;noreferrer&quot;&gt;syncthing&lt;/a&gt;) in combination with git. But the downside is there will be no connection between the source code version and the data version.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Is there any versioning system for the code and the data meeting the requirements you can recommend?&lt;/p&gt;&#xA;"/>
    <tags Tags="&lt;reproducibility&gt;&lt;data-management&gt;&lt;git&gt;"/>
    <score Score="27"/>
    <resposta>
      <id_res Id="123"/>
      <body_resp Body="&lt;p&gt;There is a couple of points to consider here, which I outline below. The goal here should be to find a workflow that is minimally intrusive on top of already using &lt;code&gt;git&lt;/code&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;As of yet, there is no ideal workflow that covers all use cases, but what I outline below is the closest I could come to it.&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Reproducibility is not just keeping all your data&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;You have got your raw data that you start your project with.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;All other data in your project directory should never just &quot;be there&quot;, but have some record of where it comes from. Data processing scripts are great for this, because they &lt;em&gt;already document how&lt;/em&gt; you went from your raw to your analytical data, and then the files needed for your analyses.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;And those scripts can be versioned, with an appropriate single entry point of processing (e.g. a &lt;code&gt;Makefile&lt;/code&gt; that describes how to run your scripts).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This way, the state of all your project files is defined by the raw data, and the version of your processing scripts (and versions of external software, but that's a whole different kind of problem).&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;What data/code should and should not be versioned&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;Just as you would not version generated code files, you should not want to version 10k intermediary data files that you produced when performing your analyses. The data that &lt;em&gt;should be&lt;/em&gt; versioned is your &lt;em&gt;raw data&lt;/em&gt; (at the start of your pipeline), not automatically generated files.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;You might want to take snapshots of your project directory, but not keep every version of every file ever produced. This already cuts down your problem by a fair margin.&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Approach 1: Actual versioning of data&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;For your &lt;strong&gt;raw or analytical data&lt;/strong&gt;, &lt;a href=&quot;https://git-lfs.github.com/&quot; rel=&quot;noreferrer&quot;&gt;Git LFS&lt;/a&gt; (and alternatively &lt;a href=&quot;https://git-annex.branchable.com/&quot; rel=&quot;noreferrer&quot;&gt;Git Annex&lt;/a&gt;, that you already mention) is designed to solve exactly this problem: add tracking information of files in your Git tree, but do not store the content of those files in the repository (because otherwise it would add the size of a non-diffable file with every change you make).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;For your &lt;strong&gt;intermediate files&lt;/strong&gt;, you do the same as you would do with intermediate code files: add them to your &lt;code&gt;.gitignore&lt;/code&gt; and do not version them.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This begs a couple of considerations:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Git LFS is a paid service from Github (the free tier is limited to 1 GB of storage/bandwidth per month, which is very little), and it is more expensive than other comparable cloud storage solutions. You could consider paying for the storage at Github or running your own LFS server (there is a reference implementation, but I assume this would still be a substantial effort)&lt;/li&gt;&#xA;&lt;li&gt;Git Annex is free, but it replaces files by links and hence changes time stamps, which is a problem for e.g. GNU Make based workflows (major drawback for me). Also, fetching of files needs to be done manually or via a commit hook&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;Approach 2: Versioning code only, syncing data&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;If your analytical data stays the same for most of your analyses, so the actual need to version it (as opposed to back up and document data provenance, which is essential) may be limited.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;The key to get this this working is to put all &lt;strong&gt;data files&lt;/strong&gt; in your &lt;code&gt;.gitignore&lt;/code&gt; and ignore all your &lt;strong&gt;code files&lt;/strong&gt; in &lt;code&gt;rsync&lt;/code&gt;, with a script in your project root (extensions and directories are an example only):&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#!/bin/bash&#xA;cd $(dirname $0)&#xA;rsync -auvr \&#xA;    --exclude &quot;*.r&quot; \&#xA;    --include &quot;*.RData&quot; \&#xA;    --exclude &quot;dir with huge files that you don't need locally&quot; \&#xA;    yourhost:/your/project/path/* .&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;The advantage here is that you don't need to remember the &lt;code&gt;rsync&lt;/code&gt; command you are running. The script itself goes into version control.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This is especially useful if you do your heavy processing on a computing cluster but want to make plots from your result files on your local machine. I argue that you &lt;em&gt;generally don't need&lt;/em&gt; bidirectional sync.&lt;/p&gt;&#xA;"/>
      <score_resp Score="15"/>
    </resposta>
  </pregunta>
  <pregunta>
    <titol Title="Why sequence the human genome at 30x coverage?"/>
    <body Body="&lt;p&gt;A bit of a historical question on a number, 30 times coverage, that's become so familiar in the field: why do we sequence the human genome at 30x coverage?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;My question has two parts:&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Who came up with the 30x value and why?&lt;/li&gt;&#xA;&lt;li&gt;Does the value need to be updated to reflect today's state-of-the-art?&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;In summary, if the 30x value is a number that was based on the old Solexa GAIIx 2x35bp reads and error rates, and the current standard Illumina sequencing is 2x150bp, does the 30x value need updating?&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&quot;https://i.stack.imgur.com/GGkq0.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/GGkq0.png&quot; alt=&quot;enter image description here&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;"/>
    <tags Tags="&lt;genome&gt;&lt;ngs&gt;&lt;phylogenetics&gt;"/>
    <score Score="27"/>
    <resposta>
      <id_res Id="2217"/>
      <body_resp Body="&lt;p&gt;The earliest mention of the 30x paradigm I could find is in the original Illumina whole-genome sequencing paper: &lt;a href=&quot;https://www.nature.com/nature/journal/v456/n7218/full/nature07517.html&quot; rel=&quot;noreferrer&quot;&gt;Bentley, 2008&lt;/a&gt;. Specifically, in Figure 5, they show that most SNPs have been found, and that there are few uncovered/uncalled bases by the time you reach 30x: &lt;a href=&quot;https://i.stack.imgur.com/42eHQ.png&quot; rel=&quot;noreferrer&quot;&gt;&lt;img src=&quot;https://i.stack.imgur.com/42eHQ.png&quot; alt=&quot;30xSequencingDepth&quot;&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;These days, 30x is still a common standard, but large-scale germline sequencing projects are often pushing down closer to 25x and finding it adequate. Every group doing this seriously has done power calculations based on specifics of their machines and prep (things like error rates and read lengths matter!).&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Cancer genomics is going in the other direction. When you have to contend with purity, ploidy, and subclonal populations, much more coverage than 30x is needed. Our group showed in &lt;a href=&quot;http://www.cell.com/cell-systems/abstract/S2405-4712(15)00113-1&quot; rel=&quot;noreferrer&quot;&gt;this 2015 paper&lt;/a&gt; that even 300x whole-genome coverage of a tumor was likely missing real rare variants in a tumor. &lt;/p&gt;&#xA;&#xA;&lt;p&gt;On the whole, the sequence coverage you need really depends on what questions you're asking, and I'd recommend that anyone designing a sequencing experiment consult with both a sequencing expert and a statistician beforehand (and it's even better if those are the same person!)&lt;/p&gt;&#xA;"/>
      <score_resp Score="30"/>
    </resposta>
  </pregunta>
</preguntes>